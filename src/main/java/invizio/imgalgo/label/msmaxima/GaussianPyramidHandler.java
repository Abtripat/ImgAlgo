package invizio.imgalgo.label.msmaxima;


import java.util.List;

import invizio.imgalgo.util.RAI;

import java.util.ArrayList;
import java.lang.Math;

import net.imglib2.type.NativeType;
import net.imglib2.type.numeric.NumericType;
import net.imglib2.util.Util;
import net.imglib2.view.Views;
import net.imglib2.RandomAccessibleInterval;
import net.imglib2.algorithm.gauss3.Gauss3;
import net.imglib2.exception.IncompatibleTypeException;
import net.imglib2.img.ImgFactory;

// todo:
// - test the class


/**
 * 
 * @author Benoit Lombardot
 * 
 * Implementation of an image gaussian pyramid. n-dimensionnal image with anisotropic resolution are handled by the implementation
 * 
 * An image pyramid is a collection of image showing an initial image at different level of details (i.e. at different scales).
 * The scale of an image is the size of the smallest detail visible in an image. When the scale become large enough it is possible
 * to downsample the image without loss of information which allow to save space in the creation of the successive level of a pyramid. 
 * 
 * The gaussian pyramid is generated by recursively applying gaussian blurring to the input image. When the scale reaches of power of 2
 * the image is downsampled. this process can be repeated as long as all image dimension are superior to 1 strictly.
 * The images with scale, 2^n >= scale > 2^(n+1), form the nth octave. One can choose the number of image in an
 * octave with the parameter nScalePerOctave. The scale, S_k+1 of image k+1 can then be deducted from image k : S_k+1 = S_k * 2^(1/nScalePerOctave)   
 *
 * This class calculates and store all levels of the pyramid when requested by the users. as levels are created recursively from previous levels
 * requested a level also generates and store all previous levels.
 * 
 * If necessary it is possible to generate more than nScalePerOctave at a particular resolution. this will create redundancy 
 * in the pyramid as images at given scale can be present a multiple sampling. However it can prove useful when used by other algorithm 
 * in practice nSuppScale is always >= to 1 as one supplementary scale is always necessary when generating the first level of the next octave.
 * To access this supplementary level one can user the getLevel(oct, octLevel)
 * 
 * @param <T>
 */
public class GaussianPyramidHandler < T extends NumericType< T > & NativeType< T > > {
	
	// parameters
	protected final RandomAccessibleInterval<T> img0;							// input image
	private double[] resolution0;
	private int nScalePerOctave;							// number of scale per Octave
	private int nSuppScalePerOctave;						// number of scale stored without downsampling (beyond the number of scale per octave ) 
	
	// deducted from parameters
	private int nDim;
	private long[] size0;
	private int nOctave;									// number of octave in the pyramid (deducted from image size )
	private int maxLevel; 									// total max number of level in the pyramid (deducted from the number of octave)  
	
	private List< List<RandomAccessibleInterval<T>> > imgPyramid;				// image at each level of an octave, each octave of the pyramid
	private List< double[] > resolutionList;				// voxel size in each octave
	//private List< List<double[]> > sigmaListPerOctave;		// blurring applied from one level to the other in each octave
	private List< List<double[]> > sigmaToNextOctaveLevel;
	private List< double[] > downSamplingToNextOctave;		// downsampling applied to go go from one octave to the next (can be different for each dimension)
	private List< double[] > downSamplingAtOctave; 			// downsampling in each octave, could be different in each dimension
	private List< long[] > imageSizeAtOctave; 				// 
	
	
	private boolean initialized=false;
	private int nThread;
	
	
	/**
	 * 
	 * @param img0 
	 * rk: resolution is set to default value 1 for every dimension of img0
	 * rk: nScalePerOctave is set to 2   
	 * rk: nSuppScalePerOctave is set to 0 
	 */	
	public GaussianPyramidHandler(RandomAccessibleInterval<T> img0)
	{
		this.img0 = img0;
		this.nScalePerOctave = 2;
		this.nSuppScalePerOctave = 1;

		this.nDim = img0.numDimensions();
		this.resolution0 = new double[nDim];
		for(int d=0; d<nDim; d++){ this.resolution0[d]=1; }
		
		
		this.nThread =  Runtime.getRuntime().availableProcessors();
		initialized=false;
	}

	/**
	 * 
	 * @param img0 
	 * @param resolution : resolution of the voxel in the image
	 * rk: nScalePerOctave is set to 2   
	 * rk: nSuppScalePerOctave is set to 0 
	 */
	public GaussianPyramidHandler(RandomAccessibleInterval<T> img0, double[] resolution )
	{
		this.img0 = img0;
		this.nScalePerOctave = 2;
		this.nSuppScalePerOctave = 1;

		this.nDim = img0.numDimensions();
		this.resolution0 = resolution;
		
		this.nThread =  Runtime.getRuntime().availableProcessors();
		initialized=false;
	}
	
	/**
	 * 
	 * @param img0 
	 * @param resolution : resolution of the voxel in the image
	 * @param nScalePerOctave :   
	 * @param nSuppScalePerOctave : 
	 */
	public GaussianPyramidHandler(RandomAccessibleInterval<T> img0, double[] resolution, int nScalePerOctave, int nSuppScalePerOctave )
	{
		this.img0 = img0;
		this.nScalePerOctave = nScalePerOctave;
		this.nSuppScalePerOctave = Math.max(1,nSuppScalePerOctave);

		this.nDim = img0.numDimensions();
		this.resolution0 = resolution;
		
		this.nThread =  Runtime.getRuntime().availableProcessors();
		initialized=false;
	}
	
	
	/**
	 * 
	 * @param i level in the pyramid
	 * @return The size of voxel in the level i image
	 * rk: images in the same octave will have the same voxel size 
	 */	
	public double[] getResolution(int level)
	{
		initializePyramid();
		if (level<0 | level>=maxLevel ){ return null; }
		int oct = level/nScalePerOctave;
		return resolutionList.get(oct);
	}
	
	/**
	 * 
	 * @param i level in the pyramid
	 * @return The downsampling factors of the level i image wrt. the input image in each image dimensions 
	 * rk: images in the same octave will have the same downsampling factors
	 */
	public double[] getDownsampling(int level)
	{
		initializePyramid();
		if (level<0 | level>=maxLevel ){ return null; }
		int oct = level/nScalePerOctave;
		return downSamplingAtOctave.get(oct);
	}
	
	/**
	 * 
	 * @param i level in the pyramid
	 * @return The scale (detail size) of the level i image (in pixel) 
	 */
	public double getPixelScale(int level)
	{
		initializePyramid();
		if (level<0 | level>=maxLevel ){ return 0; }
		double scale = Math.pow(2, (double)(level)/((double)nScalePerOctave) ); 
		return scale;
	}
	
	/**
	 * 
	 * @param i level in the pyramid
	 * @return The scale (detail size) of the level i image (in image resolution unit) 
	 */
	public double getPhysicalScale(int level)
	{
		double scale = getPixelScale(level);
		double minRes = Double.MAX_VALUE;
		for(double val : resolution0)
		{	if (val<minRes)
			{	minRes=val;
			}
		}
		return scale*minRes;
	}
	
	public int getMaxLevel()
	{
		initializePyramid();
		return maxLevel;
	}
	
	/**
	 * 
	 * @param i level of the pyramid
	 * @return return the pyramid image at level i
	 * rk: if nSuppScalePerOctave>0 the function returns the image with lowest resolution (i.e. largest octave)
	 */
	public RandomAccessibleInterval<T> getLevel(int i)
	{
		initializePyramid();
		if (i<0 | i>=maxLevel ){ return null; }
		int oct = i/nScalePerOctave;
		int octLevel = i%nScalePerOctave;
		generateLevel(oct,octLevel);
		
		return imgPyramid.get(oct).get(octLevel);
	}
	
	
	/**
	 * 
	 * @param oct : octave of the pyramid
	 * @param octLevel : level in the octave
	 * @return return the pyramid image in octave oct and octave level octLevel
	 * rk: this is the only way to generate and retrieve levels when octLevel>=nScalePerOctave
	 */
	public RandomAccessibleInterval<T> getLevel(int oct, int octLevel)
	{
		initializePyramid();
		if ( oct<0 | oct>=nOctave | octLevel<0 | octLevel>=(nScalePerOctave + nSuppScalePerOctave) ){ return null; }
		generateLevel(oct,octLevel);
		
		return imgPyramid.get(oct).get(octLevel);
	}
	
	
	
	/**
	 * adjust the number of thread used by the gaussian blurring (Imglib2)
	 * @param nThread
	 */
	public void setNThread(int nThread)
	{
		this.nThread = Math.min(  Math.max(1, nThread) ,  Runtime.getRuntime().availableProcessors()  );
	}
	
	
	////////////////////////////////////////////////////////////////////////////////////
	// private functions ////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	
	/*
	private void generateLevel(int oct, int octLevel)
	{
		if ( imgPyramid.get(oct).get(octLevel)!=null ){ return; }
		
		int pyramidLevel = oct*nScalePerOctave + octLevel;
		Img<T> img = getLevel(pyramidLevel);
		
		if ( octLevel>=nScalePerOctave )
		{
			long[] targetSize = imageSizeAtOctave.get(oct);
			Img<T> img2 = ImgLib2Utils.upsample( img, targetSize, ImgLib2Utils.Interpolator.Linear);
			imgPyramid.get(oct).set(octLevel,img2);
		}
		
	}
	*/
	
	private void generateLevel(int oct, int octLevel)
	{
		if ( imgPyramid.get(oct).get(octLevel)!=null ){ return; }
		
		if (octLevel>0)
		{	
			generateLevel(oct, octLevel-1);
			// blur previous level of the pyramid 
			RandomAccessibleInterval<T> temp = gaussianBlur( imgPyramid.get(oct).get(octLevel-1), sigmaToNextOctaveLevel.get(oct).get(octLevel-1) );
			imgPyramid.get(oct).set( octLevel , temp  );
		}
		else if(oct>0)
		{	
			generateLevel(oct-1, nScalePerOctave );
			// decimate the first supplementary level of the previous octave
			RandomAccessibleInterval<T> temp = RAI.decimate( imgPyramid.get(oct-1).get(nScalePerOctave), downSamplingToNextOctave.get(oct-1) );
			imgPyramid.get(oct).set( 0 , temp  );
		}
	
	}
	
	/*
	private void generateLevel(int i)
	{
		int oct = i/nScalePerOctave;
		int octLevel = i%nScalePerOctave;
		if ( imgPyramid.get(oct).get(octLevel)!=null ){ return; }
			
		generateOctaveBaseLevel( oct );
		
		// blur previous level of the pyramid 
		Img<T> temp = gaussianBlur( imgPyramid.get(oct).get(0), sigmaListPerOctave.get(oct).get(octLevel) );
		imgPyramid.get(oct).set( octLevel , temp  );
	}
	*/
	
	/*
	private void generateOctaveBaseLevel(int oct)
	{
		if ( imgPyramid.get(oct).get(0)!=null ){ return; }
		//if ( imgPyramid.get(oct-1).get(0)==null )
		//{
			generateOctaveBaseLevel( oct-1 );
		//}
		// blur previous level of the pyramid 
		Img<T> temp = gaussianBlur( imgPyramid.get(oct-1).get(0), sigmaListPerOctave.get(oct-1).get(nScalePerOctave) );
		// decimate it
		temp = ImgLib2Utils.decimate( temp, downSamplingToNextOctave.get(oct-1) );
		imgPyramid.get(oct).set( 0 , temp  );
	}
	*/
	
	
	private RandomAccessibleInterval<T> gaussianBlur(RandomAccessibleInterval<T> input, double[] sigma)
	{	
		T sampleT = input.randomAccess().get().createVariable();
		ImgFactory<T> imgFactory = Util.getArrayOrCellImgFactory( input, sampleT );
		RandomAccessibleInterval<T> output = imgFactory.create( input, sampleT );
				
		try {
			Gauss3.gauss(sigma, Views.extendMirrorDouble(input) , output, nThread);
		} catch (IncompatibleTypeException e) {
			e.printStackTrace();
		}	
		return output;
	}
	
	
	private void initializePyramid()
	{
		
		if ( initialized ){ return; }
		
		
		// determine the max number of octave
		this.size0 = new long[nDim];
		img0.dimensions(this.size0);
		
		long minSize = Integer.MAX_VALUE;
		for( long val : size0 )
			if (val<minSize)
				minSize= val;
		nOctave=1;
		while(minSize/2>1)
		{	nOctave++;
			minSize/=2;
		}
		maxLevel = nOctave*nScalePerOctave;
		
		
		imgPyramid = new ArrayList< List<RandomAccessibleInterval<T>> >(nOctave);
		resolutionList = new ArrayList< double[]>(nOctave);
		//sigmaListPerOctave = new ArrayList< List<double[]> >(nOctave);
		sigmaToNextOctaveLevel = new ArrayList< List<double[]> >(nOctave);
		downSamplingToNextOctave = new ArrayList< double[]>(nOctave);
		downSamplingAtOctave = new ArrayList< double[]>(nOctave);
		imageSizeAtOctave = new ArrayList< long[]>(nOctave);
		
		
		for(int oct=0; oct<nOctave; oct++)
		{	
			imgPyramid.add( new ArrayList<RandomAccessibleInterval<T>>(nScalePerOctave+nSuppScalePerOctave) );
			
			double[] resolutionOct = calcResolutionAtOctave_i(resolution0, oct);
			resolutionList.add( resolutionOct );
			downSamplingToNextOctave.add( getDownSamplingToInitializeNextOctave(resolutionOct) );
			
			if (oct>0)
			{	
				double[] downSampling = new double[nDim];
				for(int d=0; d<nDim; d++){ downSampling[d] = downSamplingToNextOctave.get(oct-1)[d]*downSamplingAtOctave.get(oct-1)[d]; }
				downSamplingAtOctave.add( downSampling );
				
				long[] imageSize = new long[nDim];
				for(int d=0; d<nDim; d++){ imageSize[d] = (int) (imageSizeAtOctave.get(oct-1)[d] / downSamplingToNextOctave.get(oct-1)[d]); }
				imageSizeAtOctave.add(imageSize);
			}
			else
			{
				double[] baseDowsampling = new double[nDim];
				for(int d=0; d<nDim; d++){ baseDowsampling[d]=1;}
				downSamplingAtOctave.add(baseDowsampling);
				
				long[] dims = new long[nDim];
				img0.dimensions(dims);
				imageSizeAtOctave.add(dims);
				
				imgPyramid.get(0).add( RAI.duplicate( img0 ) );
			}
			
			sigmaToNextOctaveLevel.add( new ArrayList<double[]>(nScalePerOctave+nSuppScalePerOctave ) );
			for( int octLevel=0; octLevel<( nScalePerOctave+nSuppScalePerOctave ); octLevel++){
				sigmaToNextOctaveLevel.get(oct).add( getSigmaToNextLevel(resolutionOct, octLevel) );
				imgPyramid.get(oct).add(null);
			}
			
		}
		
		
		initialized= true;	
	}
	
	
	
	private double[] calcResolutionAtOctave_i(double[] resolution, int i)
	{
		if (i==0)
			return resolution;
		
		int nDim = resolution.length;
		
		double minRes = Double.MAX_VALUE;
		for(int d=0;  d<nDim; d++){
			minRes = (resolution[d]<minRes) ? resolution[d] : minRes ;
		}
		
		double TargetScale = Math.pow(2, (double)i );
		double[] resolution2 = new double[nDim];
		for( int d=0; d<nDim; d++ ){
			resolution2[d] = Math.max( minRes*TargetScale, resolution[d]);
		}
		return resolution2;	
	}
	
	
	// if the resolution is not isotropic:
	// - image is blurred only if the target scale is larger that ratio between min resolution and current resolution
	// - in that case the sigma is chosen such that target^2 = ratio^2 + sigma^2
	// - otherwise the sigma is chosen equal to zero
	private static double[] getDownSamplingToInitializeNextOctave(double[] resolution)
	{
		int nDim = resolution.length;
		
		double minRes = Double.MAX_VALUE;
		for(int d=0;  d<nDim; d++){
			minRes = (resolution[d]<minRes) ? resolution[d] : minRes ;
		}
		
		double TargetScale = Math.pow(2, (double)1 );
		double[] resolution2 = new double[nDim];
		for( int d=0; d<nDim; d++ ){
			resolution2[d] = Math.max( minRes*TargetScale, resolution[d]);
		}
		
		double[] DownSampleFactor = new double[nDim]; 
		for(int d=0; d<nDim; d++){
			DownSampleFactor[d] = resolution2[d]/resolution[d];
		}
		
		return DownSampleFactor;
	}
	
	/*
	private double[] getSigmaAtOctaveLevel(double[] resolution, int level)
	{
		int nDim = resolution.length;
		
		double minRes = Double.MAX_VALUE;
		for(int d=0;  d<nDim; d++){
			minRes = (resolution[d]<minRes) ? resolution[d] : minRes ;
		}
		
		double TargetScale = Math.pow(2, (double)level/nScalePerOctave );
		double[] sigma = new double[nDim];
		for( int d=0; d<nDim; d++ ){
			double ratio = resolution[d]/minRes;
			if (  TargetScale > ratio  )
				sigma[d] = Math.sqrt( TargetScale*TargetScale - ratio*ratio );
			else //if scale <= (resolution[d]/minRes)
				sigma[d] = 0;
		}
		return sigma;
	}
	*/
	
	private double[] getSigmaToNextLevel(double[] resolution, int level)
	{
		int nDim = resolution.length;
		
		double minRes = Double.MAX_VALUE;
		for(int d=0;  d<nDim; d++){
			minRes = (resolution[d]<minRes) ? resolution[d] : minRes ;
		}
		
		double[] sigma = new double[nDim];
		double currentScale = Math.pow(2, (double)(level)/nScalePerOctave );
		double targetScale = Math.pow(2, (double)(level+1)/nScalePerOctave );
		for( int d=0; d<nDim; d++ ){
			double ratio = resolution[d]/minRes;
			if (  targetScale > ratio  )
				sigma[d] = Math.sqrt( targetScale*targetScale - Math.max(ratio*ratio, currentScale*currentScale) );
			else //if scale <= (resolution[d]/minRes)
				sigma[d] = 0;
		}
		return sigma;
	}
	

	/////////////////////////////////////////////////////////////
	// for testing  /////////////////////////////////////////////
	
	public static void main(final String... args)
	{
//		//start imageJ
//		new ij.ImageJ();
//		
//		// load an image
//		IJ.open("F:\\project_data\\test data\\blobs.tif");
//		ImagePlus imp = IJ.getImage();
//		Img<FloatType> input = ImagePlusAdapter.convertFloat(imp);
//		
//		// display the value of sigma and resolution for different resolution
//		double[] res0 = new double[] {1,1};
//		int nScalePerOctave = 2;
//		int nSuppScalePerOctave = 2;
//		int maxOctaveLevel = nScalePerOctave + nSuppScalePerOctave;
//		
//		GaussianPyramidHandler<FloatType> gaussPyramid = new GaussianPyramidHandler<FloatType>(input, res0, nScalePerOctave, nSuppScalePerOctave);
//		
//		System.out.println( "level\t"+"oct\t" + "octLevel\t" + "pixScale\t" + "phyScale\t" + "downSampling\t" + "Resolution\t" );
//		
//		int maxLev = gaussPyramid.getMaxLevel();
//		System.out.println("max level: "+ maxLev );
//		
//		for( int level = 0; level<6; level++) 
//		{	
//			double[] ds = gaussPyramid.getDownsampling(level);
//			double[] res = gaussPyramid.getResolution(level);
//			double phyScale = gaussPyramid.getPhysicalScale(level);
//			double pixScale = gaussPyramid.getPhysicalScale(level);
//			
//			int oct = level/nScalePerOctave;
//			int octLevel = level%nScalePerOctave; 
//			System.out.println( level+"\t"+oct+"\t"+octLevel+"\t"+
//								pixScale+"\t"+
//								phyScale+"\t"+
//								Arrays.toString(ds)+"\t"+
//								Arrays.toString(res)+"\t"
//								);
//			
//			Img<FloatType> imgLevel = gaussPyramid.getLevel(level); 
//			ImgLib2Utils.convertImgToImagePlus(imgLevel, imp.getTitle()+"_"+level+"_"+oct+"_"+octLevel, "Grays", imp.getDimensions(), imp.getCalibration() ).show();
//			
//			
//			if( octLevel == nScalePerOctave-1)
//			{
//				int equivLevel = level;
//				octLevel++;
//				equivLevel++;
//				while (octLevel<maxOctaveLevel && equivLevel<maxLev)
//				{
//					ds = gaussPyramid.getDownsampling(equivLevel);
//					res = gaussPyramid.getResolution(equivLevel);
//					phyScale = gaussPyramid.getPhysicalScale(equivLevel);
//					pixScale = gaussPyramid.getPhysicalScale(equivLevel);
//					
//					System.out.println( equivLevel+"\t"+oct+"\t"+octLevel+"\t"+
//							pixScale+"\t"+
//							phyScale+"\t"+
//							Arrays.toString(ds)+"\t"+
//							Arrays.toString(res)+"\t"
//							);
//					
//					Img<FloatType> imgSuppLevel = gaussPyramid.getLevel(oct, octLevel); 
//					ImgLib2Utils.convertImgToImagePlus(imgSuppLevel, imp.getTitle()+"_"+equivLevel+"_"+oct+"_"+octLevel, "Grays", imp.getDimensions(), imp.getCalibration() ).show();
//					
//					octLevel++;
//					equivLevel++;
//				}
//			}
//		}
//		
		
	}
	
	
}
